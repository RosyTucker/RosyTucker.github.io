---
layout: post
title: "HTTP, HTTPS and SSL/TLS"
date: 2016-02-08
category: blog
---

Most developers have written code that sends a HTTP request and reads the response, many have also sent HTTPS 
requests. This article aims to explain the difference between the two, and how HTTPS works in detail.

HTTP and HTTPS
================

HTTP is a protocol, it defines the format of a communication between a client and a server, including the request and 
response, to ensure that both parties understand each other.

When a client sends a HTTP request to a server, the contents of that request are in plain text. 
This approach is therefore open to a **Man in the Middle** attack, where a third party could easily eavesdrop, or 
pretend to be the client or the server in the conversation.

HTTPS is another such protocol, the 'S' here stands for secure. People are generally aware that HTTPS is the better 
option. But why and what does it really mean?

Ciphers
================

When server receives an initial request from a client over HTTPS, the two parties perform something called **cipher 
suite negotiation**. The client supports a certain set of ciphers, as does the server, the two must agree on which to
 use for further communication.
 
The client sends the server a list of the ciphers it supports, normally in order of preference. The server examines 
the list and determines which of the ciphers, if any it will use. If both parties support the same cipher, then good 
news ... we can start encrypting.

Not all ciphers are secure
------

It's worth noting that, the fact that the client and server support the same cipher *does not mean that said cipher is 
secure*. Take RC4 for example, many servers and clients will still use this cipher in some cases, even though it is 
insecure. When building an application, be sure to check which ciphers you intend to support. It is often a trade off 
between browser compatibility and security, so be conscious of this when choosing your supported browsers.

HTTPS and Certificates
================

HTTPS requests are encrypted in transport between the client and the server, in order to do this, the server requires
 a certificate. This certificate is sent to the client when first contact is made, for example, when you load 
 [https://github.com](https://github.com).

The certificate is used to identify the server, as a particular domain name and company. A certificate authority (CA)
 signs this certificate saying that they trust these details to be correct. The certificate binds the domain name to 
 a public key, this public key will be used as part of the encryption process.

Handshake and Certificate exchange
================

Once the server knows it can perform encryption with the client, and the cipher has been agreed, it must hand over it's 
certificate for inspection by the client.

The client will check the domain name of the certificate, if it matches the address of the domain name to which the 
client is talking to  then the client will check the certificate against its trusted CAs. If the certificate was 
signed by a trusted CA then the client will take the public key provided by the certificate, and use it to start 
communicating securely.

So, given the servers certificate has been validated by the client, we are now ready to start sending encrypted 
requests. Well not just yet, the client and server need to perform a handshake in order to generate a shared key.

The specifics of this handshake vary depending on the protocol used. Previously SSL (secure sockets layer) was used for 
this exchange, however, this has been replaced by TLS (transport layer security), although the terms are often used 
analogously.
Many think that the reason for this change is because the two protocols are vastly different, however, the actual 
reason is a [legal one](https://en.wikipedia.org/wiki/Transport_Layer_Security). TLS should be seen as the natural 
progression of SSL, in fact many people call TLS 1.0, SSL 3.1.

At the moment of writing TLS 1.2 is the preferred protocol for the handshake. I will not go into the 
specifics of the handshake in this article, however, there is a good explanation [here](http://www-01.ibm.com/support/knowledgecenter/?lang=en#!/SSFKSJ_7.1.0/com.ibm.mq.doc/sy10660_.htm).

 
Certificate Authorities
===============

As an aside, an important thing to remember here is that this process all relies on the CA being trusted. Certificate
 authorities have a root certificate, this certificate is used to sign further certificates. Browsers normally come 
 with these root certificates installed, so that they can identify fraudulent certificates that have not been correctly 
 signed. If a CA becomes compromised, a browser may remove its root certificate from its trusted set and thus will 
 report any sites trying to communicate over HTTPS with a certificate signed with this root certificate as insecure.

In the same way that the browser has a copy of the CA root certificates, and does not need to rely on anyone else in order to
check the authenticity of a certificate, a client can keep a copy of a servers certificate. This is known as 
**certificate pinning**. 

If a client pins the certificate of a server it means that it does not require a CA in order check the authenticity 
of a server’s certificat. Instead, it can just check whether the received certificate matches the certificate it 
already has. This means that a client can say that it will only trust a particular certificate, or set of certificates.
This is much more secure than having to trust a CA.

For example, a mobile app may ship with the certificate for the domain that it’s API is hosted on, meaning it will 
only trust communications from the API's domain. Google Chrome also uses a [variation](https://www.chromium.org/hsts)
of this mechanism.

Summary
===============

So after cipher suite negotiation, certificate exchange, and a handshake, the two parties are able to communicate over
 an encrypted channel. At any point it is possible for some part of the process to become insecure, whether the 
 cipher, or the CA, or the handshake protocol itself. It is therefore always worth being vigilant and updating your 
 products when new vulnerabilities or more secure technologies are found.